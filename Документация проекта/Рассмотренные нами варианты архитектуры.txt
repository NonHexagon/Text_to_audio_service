
1)	Стильные, модные, молодёжные микросервисы: 
При таком подходе приложение разрабатывается как набор небольших сервисов, каждый из которых работает в собственном процессе и связывается с легковесными механизмами, обычно API для HTTP-ресурса.

Эти сервисы основываются на бизнес-возможностях и могут развертываться независимо друг от друга с помощью полностью автоматизированного механизма.
Централизованное управление между сервисами минимально. Они могут быть написаны на разных языках, использовать разные технологии хранения данных.
Архитектура работает по принципу компонентизации сервисов. Она разделяет программное обеспечение на различные изолированные компоненты (сервисы), каждый из которых несет единую ответственность. Изменения в одноv сервисе не должны затрагивать другие
+ Очень гибкая
+ Легко расширяется и масштабируется
+ минус риски возникновения проблем с потоками данных
- не для микрокоманд, управление разработкой будет адским. 
- Один микросервис не должен лезть в зону ответственности другого и дублировать его функционал. Круто, а где его зона ответственности?
- Надо проработать взаимодействия сервисов
- Сложнее управлять
- Повышенный риск сбоя при обмене данными между сервисами
Итого: Никто не захотел возиться с разделением сервисов. С молчаливого согласия команды снят с рассмотрения, так как не укладывался в наши запасы сил и времени
2)	Многослойная архитектура
Этот подход работает по принципу разделения ответственностей. ПО разделено на слои, лежащие друг на друге, и каждый из них выполняет определенную обязанность.
Архитектура делит ПО на следующие слои.
Слой представления (Presentation Layer) содержит пользовательский интерфейс и отвечает за обеспечение хорошего пользовательского опыта.
Слой бизнес-логики (Business Logic Layer), как следует из названия, содержит бизнес-логику приложения. Он отделяет UI/UX от вычислений, связанных с бизнесом. Это позволяет с легкостью изменять логику в зависимости от постоянно меняющихся бизнес-требований, никак не влияя на другие слои.
Слой передачи данных (Data Link Layer) отвечает за взаимодействие с постоянными хранилищами, такими как базы данных, и прочую обработку информации, которая не связана с бизнесом.
Данные и элементы управления проходят через каждый слой в дизайне и передаются от одного к другому. Эта система также повышает уровень абстракции и в некоторой степени даже стабильность ПО.
•	каждый слой занимается конкретной задачей.
•	логика разных слоёв не повторяется и не пересекается
•	способ обращения к нижестоящему слою чётко определён
•	способ поставки информации вышестоящему слою чётко определён
•	слои слабо связаны
•	слои расположены вертикально, хотя есть сквозная функциональность, которая может пронизывать пирамиду сверху вниз
•	слои могут размещаться физически на одном компьютере ( в пределах одного уровня), а могут быть на разных машинах, например, в распределённых приложениях.
•	логика разных слоёв инкапсулирована, соответственно, разным слоям не нужно делать никаких предположений о том, как реализован код других слоёв приложения.
•	возможность использования в других сценариях (за счёт слабого связывания и чётко определённой задачи).
+ Проще сделать
+ абстракция из-за разделения ответственности между уровнями.
+ если сломаем один слой, то скорее всего не сломали другие (Да, все поняли к чему это)
+ слабая связанность. Проще управлять
+ Проще подключать фичи….  в начале
- Сложнее масштабировать 
- С определённого момента сложнее вносить фичи
- Необходимость передавать данные по всем слоям
Итого: В результате обсуждения отклонён из-за возможных проблем с дальнейшим допиливанием проекта.
3)	Многоуровневая архитектура
Этот архитектурный подход разделяет комплекс ПО на уровни по принципу взаимодействия “клиент-сервер”. Архитектура может иметь один, два и больше уровней, разделяющих ответственности между поставщиком данных и потребителем.
Этот подход использует шаблон Request Response для связи между уровнями. В отличие от многослойной архитектуры, он предлагает масштабируемость, которая может быть как горизонтальной (масштабирование сети с помощью высокопроизводительных узлов), так и вертикальной (масштабирование каждого узла путем повышения его производительности).
Одноуровневая система
В данном подходе единая система работает как на стороне сервера, так и клиента. Это обеспечивает простоту развертывания и отличную скорость связи, а также устраняет необходимость межсистемного взаимодействия (Inter-system communication — ISC).
Такая система подходит только для небольших однопользовательских приложений.
Двухуровневая система
Эта система состоит из двух физических машин в качестве сервера и клиента. Она обеспечивает изоляцию операций управления данными, обработки данных и операций представления.
Клиент содержит слои презентации, бизнес-логики и передачи данных.
Сервер включает хранилища и базы данных.
Трехуровневая и n-уровневая системы
Такие архитектуры обладают высокой масштабируемостью как по горизонтали, так и по вертикали. Реализация n-уровневой системы, как правило, обходится дороже, но обеспечивает высокую производительность. Поэтому она обычно применяется в крупных и комплексных программных решениях.
+ хорошо масштабируется во все стороны
+ разнопрофильные разработчики теперь могут работать независимо
+ упрощение «специализации» разработчиков в проекте
- может оказаться дорогостоящей по времени и силам
- возможен разрыв между «специализированными» разработчиками
- риск застопоривания проекта при проблемах у одного из членов команды
Итого: Выбран для проекта. В текущей версии – двухуровневая, в данный момент планируется перевод на трёхуровневую (добавление базы данных)
4)	Сервис-ориентированная архитектура
Эта архитектурная модель состоит из компонентов и приложений, которые связываются друг с другом с помощью четко определенных сервисов. Вызывающая программа (caller) вызывает локальную процедуру, реализованную заглушкой.
Заглушка проверяет вызов, создаёт сообщение-запрос и передаёт его в ORB.
Клиентский ORB шлёт сообщение по сети на сервер и блокирует текущий поток выполнения.
Серверный ORB получает сообщение-запрос и создаёт экземпляр скелета.
Скелет исполняет процедуру в вызываемом объекте.
Вызываемый объект проводит вычисления и возвращает результат.
Скелет пакует выходные аргументы в сообщение-ответ и передаёт его в ORB.
ORB шлёт сообщение по сети клиенту.
Клиентский ORB получает сообщение, распаковывает и передаёт информацию заглушке.
Заглушка передаёт выходные аргументы вызывающему методу, разблокирует поток выполнения, и вызывающая программа продолжает свою работу.
+ Независимость от выбранных технологий (не считая реализации ORB).
+ Независимость от особенностей передачи данных/связи.
- клиентский код понятия не имеет, является ли вызов (локальный или удалённый?). 
- Особенности спецификации
- используются специфические протоколы поверх TCP/IP, а также специфические порты (или даже случайные порты). 
Итого: Отклонено в связи с рисками длительных задержек и сбоев, что не удовлетворяет требованиям


